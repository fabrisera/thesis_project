```{r}
library(forecastML)
library(dplyr)
library(DT)
library(ggplot2)
library(xgboost)
```

```{r}
data = read.csv("../../data/processed/lstm_standardized.csv")
data$Year = data$Year + 2011
```

```{r}
# converting firm ID so that Xgboost can use it
data$Id <- as.numeric(factor(data$Id))
```

```{r}
# subset Id, Industry, Continent, Country, Year, Ghg.Change.Real.Next
data <- data %>% select(Id, Industry, Continent, Country, Year, Ghg.Change.Real.Next)

```

```{r}
data$Country <- as.numeric(factor(data$Country))
data$Industry <- as.numeric(factor(data$Industry))
data$Continent <- as.numeric(factor(data$Continent))
```

```{r}
data$Year <- as.Date(paste(data$Year, "-01-01", sep=""))
```

```{r}
# Move Ghg.Change.Real.Next to the first column
data <- data[, c(6, 1:5)]
```

```{r}
outcome_col <- 1
horizons <- c(1)
lookback <- c(1:2)
dates <- data$Year
data$Year <- NULL 
frequency <- "1 year"
dynamic_features <- c("Year")
groups <- "Id"
static_features <- c("Industry", "Continent", "Country")
```

```{r}
type <- "train"

data_train <- forecastML::create_lagged_df(data, type = type, outcome_col = outcome_col,
                                           horizons = horizons, lookback = lookback,
                                           dates = dates, frequency = frequency,
                                           dynamic_features = dynamic_features,
                                           groups = groups, static_features = static_features, 
                                           use_future = FALSE)

```


```{r}
windows <- forecastML::create_windows(data_train, window_length = 2, window_start = as.Date("2020-01-01"), window_stop = as.Date("2021-01-01"), include_partial_window = FALSE)

p <- plot(windows, data_train) + theme(legend.position = "none")
p

```


```{r}
p <- plot(windows, data_train, group_filter = "Id == 3") + 
  theme(legend.position = "none")
p
```



```{r}
# The value of outcome_col can also be set in train_model() with train_model(outcome_col = 1).
model_function <- function(data, outcome_col = 1) {
  
  # xgboost cannot handle missing outcomes data.
  data <- data[!is.na(data[, outcome_col]), ]

  indices <- 1:nrow(data)
  
  set.seed(224)
  train_indices <- sample(1:nrow(data), ceiling(nrow(data) * .8), replace = FALSE)
  test_indices <- indices[!(indices %in% train_indices)]

  data_train <- xgboost::xgb.DMatrix(data = as.matrix(data[train_indices, 
                                                           -(outcome_col), drop = FALSE]),
                                     label = as.matrix(data[train_indices, 
                                                            outcome_col, drop = FALSE]))

  data_test <- xgboost::xgb.DMatrix(data = as.matrix(data[test_indices, 
                                                          -(outcome_col), drop = FALSE]),
                                    label = as.matrix(data[test_indices, 
                                                           outcome_col, drop = FALSE]))

  params <- list("objective" = "reg:squarederror")
  watchlist <- list(train = data_train, test = data_test)
  
  set.seed(224)
  model <- xgboost::xgb.train(data = data_train, params = params, 
                              max.depth = 8, nthread = 2, nrounds = 30,
                              metrics = "rmse", verbose = 0, 
                              early_stopping_rounds = 5, 
                              watchlist = watchlist)

  return(model)
}

```

```{r}
model_results_cv <- forecastML::train_model(lagged_df = data_train,
                                            windows = windows,
                                            model_name = "xgboost",
                                            model_function = model_function, 
                                            use_future = FALSE)
```


```{r}
# If 'model' is passed as a named list, the prediction model would be accessed with model$model or model["model"].
prediction_function <- function(model, data_features) {
  x <- xgboost::xgb.DMatrix(data = as.matrix(data_features))
  data_pred <- data.frame("y_pred" = predict(model, x))
  return(data_pred)
}
```


```{r}
data_pred_cv <- predict(model_results_cv, prediction_function = list(prediction_function), data = data_train)
```

```{r}
plot(data_pred_cv) + theme(legend.position = "none")
```
```{r}
data_error <- forecastML::return_error(data_pred_cv)
```

```{r}
plot(data_error, type = "global", group_filter = "Id %in% c(1, 2, 3, 4, 5, 6, 7)", metric = "mae")
```
```{r}
mean(data_error$error_global$rmse)
```